<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta name="description" content="Halma is a PC-Game, which is a part of the '7 by one stroke' package, translated from C++ into HTML and JavaScript">
<meta name="author" content="Lutz Tautenhahn">
<meta name="keywords" content="Game, Halma, Streich, Stroke, JavaScript">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Halma</title>
<script language="JavaScript">
var i, j, MaxFld=16, MaxMove=217, MaxMoveLine=32;
var NDraw, IsOver, Start0, CanJump, I_Sel, J_Sel;
var MoveCount, MaxMoveCount, Start;    <!-- variables de gestion de mouvement -->
IsPlayer = new Array(2);   <!-- table pour 2 joueurs--> 
Level = new Array(2);      <!-- table pour 2 niveau-->
Fld = new Array(MaxFld);   <!--fld matrice de 16*16 ele présente le plateau-->
for (i=0; i<MaxFld; i++)
  Fld[i] = new Array(MaxFld); 
MoveLine = new Array(MaxMoveLine); <!--array pour les mouvements de 32 ele--> 
for (i=0; i<MaxMoveLine; i++)
  MoveLine[i] = new Array(2);      <!-- chaque ele de MoveLine est une sous-liste de coordonnés-->
<!-- variable identique a MoveLine :  NCLine --> 
var NLine;                         <!-- variable compteur de mouvements--> 
MoveCLine = new Array(MaxMoveLine);
for (i=0; i<MaxMoveLine; i++)
  MoveCLine[i] = new Array(2);
var NCLine;
FldH = new Array(MaxMove+7);       <!-- fldH array de 217+7 ele il sert à gerder trace historique des mouvements-->
for (i=0; i<MaxMove+7; i++)
  FldH[i] = new Array(4);          <!--chaque ele de fldH est une sous liste de 4 ele coordonnés départ et arrivée-->

Pic= new Array(2);                 <!--Pic matrice 2*6-->
for (i=0; i<2; i++)
  Pic[i] = new Array(6);            <!-- cette matrice est destine a acceuillir des images -->
for (i=0; i<2; i++)
{ for (j=0; j<6; j++)
  { Pic[i][j] = new Image();
    Pic[i][j].src = "halma"+eval(i)+eval(j)+".gif";
  }
}

Start0=1;                         <!-- Start Variable -->
Level[0]=0;                       <!--initialiser les levels dans la table Level -->
Level[1]=1;
IsPlayer[0]=true;                 <!-- passer la main au joueur -->>
IsPlayer[1]=false; 


<!-- cette fonction update les valeurs de: Isplayer, Level, et Start0 selon les options selectionnées-->
<!-- si m=0, le mode joueur est activé n=0 pour jaune et n=1 pour vert-->
<!-- si m !=0, le level dans Level est updated m=1 mode avance m=2 mode expert-->
<!-- sinon (2, 0) (2, 1) sert à initialiser la valuer de Start0 à 0 pour jaune 1 pour vert -->
<!-- selon le valeur de Start0 lutilisateur jaune ou vert va commencer -->  
function SetOption(n, m)
{ if (n<2) 
  { if (m==0)
      IsPlayer[n]=true;
    else
    { IsPlayer[n]=false;
      Level[n]=m-1;
    }
  }
  else Start0=m; 
}

<!-- cette fonction recommence le jeu en appelant la fonction RefreshScreen selon la valeur de NDraw -->
<!--et permet de jouer contre IA qui s execute avec la fonction MakeBestMove() --> 
function Timer()
{ if (NDraw>0) RefreshScreen();
  else
  { if ((! IsPlayer[0])||(! IsPlayer[1]))
      MakeBestMove();
  }
}


<!-- cette fonction permet de valider un click -->
<!-- pls sénario possible le jeu est terminé ,ce n est pas la tour de l utilisateur, ou lutilisateur restart le jeu rreturn --> 
<!--sinon check la validité du coup avec Pressed(), si invalide alert à l écran -->
function Clicked(ii, jj)
{ if (IsOver) return;
  if (! IsPlayer[(MoveCount+Start)%2]) return;
  if (NDraw>0) return;
  if (Pressed(ii, jj))
    RefreshScreen();
  else
    alert ("Ungültiger Zug !");
}

function Pressed(ii, jj)    <!-- coordonnés ou le joueur a cliqué ii, jj -->
{ var kk, ddi, ddj, cci, ccj, dd, nn;
  cci=0; ccj=0; nn=0;
<!-- dans le code suivant MoveLine est matrice (32*2) qui enregistre les coordonnée des cases ou le joueur click dessus -->
<!-- dans le code suivant I_Sel  est l abscisse de la case départ J_sel l ordonnée -->

  for (kk=0; kk<NLine-1; kk++)                          <!-- ici on vérifie si le joueur click sur une case par ou il a deja passé-->
  { if ((MoveLine[kk][0]==ii)&&(MoveLine[kk][1]==jj))   <!-- si oui-->
    { if (kk>0) NLine=kk+1;                             <!-- s il s agit pas de la case de depart (la première), on update NLine ( je pense q on annule (overwrite ds MoveLine) les mouvement après la dite case-->
      else                                              <!-- si il revient à la case de départ-->
      { NLine=0;                                        <!-- on remet tous aux valeurs initiales -->
        I_Sel=-1;
        J_Sel=-1;
      }
      return(true);                                     <!-- et bien sur on return True car ses mouvement sont valides -->
    }
  }
  if (NLine==MaxMoveLine) return(false);    <!-- si maximum de mouvements est joué return False (maximum= 32 mouvements) -->
  MoveLine[NLine][0]=ii;                    <!-- sinon rajouter les ccordonnées à la matrice des mouvements MoveLine-->
  MoveLine[NLine][1]=jj;                    <!-- Nline est le dernier index vide ds MovLine -->
  if (NLine==0)                              <!-- cas particulier ou le jeu a commencé NLine = 0 -->
  { if (Fld[ii][jj]!=(MoveCount+Start)%2)    <!-- je pense ici vérification si saut valide Fld est initié dans Init()-->
      return(false);
    else                                     <!-- sinon valider le saut  -->
    { NLine++;                               <!-- incrémente NLine-->
      I_Sel=ii;                              <!-- mettre I_sel et J_sel à ii, jj -->
      J_Sel=jj;
      CanJump=true;                          <!-- permettre le saut -->
      return(true);                          <!-- return True -->
    }
  }
  else
  { if (NLine==1)                            <!-- cas particulier second mouvement -->
    { if ((MoveLine[0][0]==ii)&&(MoveLine[0][1]==jj)) <!-- si retour à la case départ initialise vaiables et valide le mouvement-->
      { NLine=0;
        I_Sel=-1;
        J_Sel=-1;
        return(true);
      }
    }
    if (Fld[ii][jj]!=-1)                       <!-- si case ds plateau fld est occupé (une case inoccupée est marqué -1 ds Fld)
      return(false);                           <!--mouvement invalide -->
  }
  if ((MoveLine[NLine-1][0]==ii)&&(MoveLine[NLine-1][1]==jj)) <!-- si retour à la case précédente -->  
  { if ((ii!=MoveLine[0][0])||(jj!=MoveLine[0][1]))           <!-- si ce n est pas la case de départ valide le mouvement-->
    { MakeMove(ii, jj);
      MoveText();
    }
    NLine=0;                                                  <!-- sinon remettre Nline à 0 :retour à la case départ  -->
    return(true);
  }
  ddi=ii-MoveLine[NLine-1][0];                                <!-- calcule la distance entre coordonnées avec la case précédente-->
  ddj=jj-MoveLine[NLine-1][1];
  if ((Math.abs(ddi)<2)&&(Math.abs(ddj)<2))                   <!-- si < 2 un mouvement sans saut
  { if (NLine==1)                                             <!-- s il s agit d un premier mouvement sans saut -->
    { CanJump=false;
      NLine++;
      return(true);                                           <!-- c est valide -->
    }
    else return(false);                                       <!-- sinon impossible de faire plus de 1 mouvement sans saut -->
  }
  if (CanJump)
  { if ((ddi!=0)&&(ddj!=0)&&(Math.abs(ddi)!=Math.abs(ddj))) return(false); <!-- si mouvement sur diagonale mais ddj!= ddi invalide -->
    if (Math.abs(ddi)%2>0) return(false);                                  <!-- si saut pas symétrique invalide -->
    if (Math.abs(ddj)%2>0) return(false);                                  <!-- même chose pour ddj --> 
    if (Fld[ii-ddi/2][jj-ddj/2]<0) return(false);                          <!-- si la case au milieu = -1 inoccupée invalide -->
    if ((ii-ddi/2==I_Sel)&&(jj-ddj/2==J_Sel)) return(false);               <!-- ici je pense empecher le joueur de prendre en compte le point de départ  comme point d assymétrie à vérifier sur le jeu -->
  <!-- il faut noter que pour des mouvement droits en horizontal ou vertical cci ccj rete initié à 0 -->
    if (ddi<0) cci=-1;
    if (ddi>0) cci=1;
    if (ddj<0) ccj=-1;
    if (ddj>0) ccj=1;
    dd=Math.abs(ddi);
    if (dd<Math.abs(ddj)) dd=Math.abs(ddj);   <!--dd contient max distance entre les deux point de mouvements -->
    <!--ici vérification que toutes les cases intermédiares sont vides -->
    for (kk=0; kk<dd; kk++)
    { if (Fld[ii-kk*cci][jj-kk*ccj]!=-1)
      { if (((ii-kk*cci)!=I_Sel)||((jj-kk*ccj)!=J_Sel))
          nn++;                               
      }
    }
    if (nn>1) return(false);           <!-- si case intermédiare occupée >1 (car on compte le point d asymétrie) mouvement invalide -->
    NLine++;
    return(true);                      <!-- sinon valider le mouvement -->
  }
  return(false);                       <!-- si CanJump set à 0 invalide mouvement  -->
}
<!-- cette fonction sert à annuler le dernier coup joué lié au bouton <<-->
function Back()
{ if (MoveCount>0)                     <!--on vérifie quand meme qu un coup est joué --> 
  { IsOver=false;                      <!--possibilité de revenir en aarière meme partie finie -->
    NLine=0;
    NCLine=0;
    MoveCount--;
    Fld[FldH[MoveCount][2]][FldH[MoveCount][3]]=-1;      <!--marquer case comme inoccuppé avec -1 -->
    Fld[FldH[MoveCount][0]][FldH[MoveCount][1]]=(MoveCount+Start)%2; <!-- marquer la case précédente comme occuppée 0 ou 1-->
    I_Sel=-1;
    J_Sel=-1;
    RefreshScreen();     <!-- redessinner le plateau -->
  }
}
<!-- cette fonction sert à rejouer le dernier coup annullé lieé au bouton >>-->
function Replay()
{ if (MoveCount<MaxMoveCount)
  <!-- restaure les coordonnées précédent et actuelles -->
  { I_Sel=FldH[MoveCount][0];
    J_Sel=FldH[MoveCount][1];
    var ii=FldH[MoveCount][2];
    var jj=FldH[MoveCount][3];
    <!-- rejouer le mouvement -->
    MakeMove(ii, jj);
    MoveText();
    NCLine=0;
  }
}

<!-- cette fonction initialise les variables globales elle est appelée au lancement de la page ligne 664 et aussi -->
<--! appelé lorsque le joueur appuie sur restart -->
function Init()
{ var ii, jj;
  for (ii=0; ii<MaxFld; ii++)
  { for (jj=0; jj<MaxFld; jj++)
      Fld[ii][jj]=Home(jj, ii);
  }
  IsOver=false;
  NLine=0;
  NCLine=0;
  CanJump=true;
  MoveCount=0;
  MaxMoveCount=0;
  I_Sel=-1; J_Sel=-1;
  if (Start0>0) Start=0;
  else Start=1;
  NDraw=0;
  RefreshScreen();
}

function Home(ii, jj)
{ var dd;
  if ((dd=MaxFld-6+ii-jj)<0) return(1);
  if ((dd==0)&&(ii>0)&&(jj<MaxFld-1)) return(1);
  if ((dd=MaxFld-6+jj-ii)<0) return(0);
  if ((dd==0)&&(jj>0)&&(ii<MaxFld-1)) return(0);
  return(-1);
}

function IsInField(ii, jj)
{ if (ii<0) return(false);
  if (ii>=MaxFld) return(false);
  if (jj<0) return(false);
  if (jj>=MaxFld) return(false);
  return(true);
}

function FindJumpFields(kk, ll)
{ var iid, jjd, iik, jjk, dd, mm, nn, iis, jjs, cc;
  mm=-2;
  do
  { cc=false;
    for (iik=0; iik<MaxFld; iik++)
    { for (jjk=0; jjk<MaxFld; jjk++)
      { if (Fld[iik][jjk]==mm)
        { for (iid=-1; iid<=1; iid++)
          { for(jjd=-1; jjd<=1; jjd++)
            { if ((iid!=0)||(jjd!=0))
              { iis=iik;
                jjs=jjk;
                while (IsInField(iis+iid, jjs+jjd)&&(Fld[iis][jjs]<0))
                { iis+=iid; jjs+=jjd;
                }
                if ((IsInField(2*iis-iik, 2*jjs-jjk))&&(Fld[iis][jjs]!=ll))
                { iis*=2;
                  iis-=iik;
                  jjs*=2;
                  jjs-=jjk;
                  dd=0;
                  nn=0;
                  while ((iis-dd*iid!=iik)||(jjs-dd*jjd!=jjk))
                  { if (Fld[iis-dd*iid][jjs-dd*jjd]>=0) nn++;
                    dd++;
                  }
                  if (nn==1)
                  { if (Fld[iis][jjs]==-1) Fld[iis][jjs]=mm-1;
                    cc=true;
                    if ((Level[kk]==0)&&(mm<=-7)) cc=false;
                  }
                }
              }
            }
          }
        }
      }
    }
    mm--;
  }
  while (cc);
  return(mm);
}

function CleanUpFields()
{ var iik, jjk;
  for (iik=0; iik<MaxFld; iik++)
  { for (jjk=0; jjk<MaxFld; jjk++)
    { if (Fld[iik][jjk]<0) Fld[iik][jjk]=-1;
    }
  }
}

function MakeBestMove()
{ var ii, jj, iid, jjd, iik, jjk, kk, dd, mm, nn, iis, jjs;
  var iib, jjb, bb, bb2, bbval, pparity, iismm;
  bbval=-1000;
  pparity=0;
  if (IsOver) return;
  kk=(MoveCount+Start)%2;
  if (IsPlayer[kk]) return;
  I_Sel=-1;
  J_Sel=-1;
  NCLine=0;
  for (ii=0; ii<MaxFld; ii++)
  { for (jj=0; jj<MaxFld; jj++)
    { if (Fld[ii][jj]==kk) pparity=pparity+(ii+jj+1-MaxFld);
    }
  }
  for (ii=0; ii<MaxFld; ii++)
  { for (jj=0; jj<MaxFld; jj++)
    { if (Fld[ii][jj]==kk)
      { //setting all reachable fields to -3
        Fld[ii][jj]=-2;
        FindJumpFields(kk, 2);
        Fld[ii][jj]=kk;
        for (iik=ii-1; iik<=ii+1; iik++)   //FindStepFields
        { for (jjk=jj-1; jjk<=jj+1; jjk++)
          { if (IsInField(iik, jjk))
            { if (Fld[iik][jjk]<0) Fld[iik][jjk]=-2;
            }
          }
        }
        //getting best move for Field[ii][jj]   Be carefull with the weights
        for (iik=0; iik<MaxFld; iik++)
        { for (jjk=0; jjk<MaxFld; jjk++)
          { if (Fld[iik][jjk]<-1)
            { bb=(40*kk-20)*(ii-iik-jj+jjk);  //main direction
              if (MoveCount<19) bb+=Math.floor(Math.random()*1000)%(30-MoveCount); 
              //random influence
              else bb+=Math.floor(MoveCount/16)*(2*kk-1)*(ii-jj); 
              //move the last ones first
              if (MoveCount<54)
                bb+=Math.floor(MoveCount/9)*(Math.abs(pparity)-Math.abs(pparity-ii+iik-jj+jjk));
              //parity
              else
                bb+=6*(Math.abs(pparity)-Math.abs(pparity-ii+iik-jj+jjk)); //parity
              bb2=ii+jj+1-MaxFld; //keep the stones in the middle line
              bb+=2*bb2*bb2;
              bb2=iik+jjk+1-MaxFld;
              bb-=2*bb2*bb2;
              if (Level[kk]==0) bb+=Math.floor(Math.random()*1000)%20;
              else
              { if (kk==0) //don't forget the last 3 pieces
                { if (MaxFld-3+ii-jj<0) bb+=2*MoveCount; }
                else
                { if (MaxFld-3+jj-ii<0) bb+=2*MoveCount; }
              }
              if (bb>bbval)
              { I_Sel=ii;
                J_Sel=jj;
                iib=iik;
                jjb=jjk;
                bbval=bb;
              }
            }
          }
        }
        CleanUpFields();
      }
    }
  }
  if ((Level[kk]==1)&&(MoveCount>49)&&(Math.abs(I_Sel-iib)<2)&&(Math.abs(J_Sel-jjb)<2))
  { Fld[I_Sel][J_Sel]=-1;
    for (ii=I_Sel-1; ii<=I_Sel+1; ii++)   //FindStepFields
    { for (jj=J_Sel-1; jj<=J_Sel+1; jj++)
      { if (IsInField(ii, jj)&&((ii!=I_Sel)||(jj!=J_Sel))&&(Fld[ii][jj]<0))
        { Fld[ii][jj]=-2;
          if (FindJumpFields(kk, 1-kk)<-3)
          { //getting best move for Field[ii][jj]   Be carefull with the weights
            for (iik=0; iik<MaxFld; iik++)
            { for (jjk=0; jjk<MaxFld; jjk++)
              { if ((Fld[iik][jjk]<-1)&&((ii!=I_Sel)||(jj!=J_Sel)))
                { bb=(40*kk-20)*(I_Sel-iik-J_Sel+jjk);  //main direction
                  bb+=Math.floor(MoveCount/16)*(2*kk-1)*(I_Sel-J_Sel); //move the last ones first
                  bb+=6*(Math.abs(pparity)-Math.abs(pparity-I_Sel+iik-J_Sel+jjk));  //parity
                  bb2=I_Sel+J_Sel+1-MaxFld; //keep the stones in the middle line
                  bb+=2*bb2*bb2;
                  bb2=iik+jjk+1-MaxFld;
                  bb-=2*bb2*bb2;
                  bb-=30;
                  if (bb>bbval)
                  { iib=ii;
                    jjb=jj;
                    bbval=bb;
                  }  	 
                }
              }
            }
          }
          CleanUpFields();
        }
      }
    }
    Fld[I_Sel][J_Sel]=kk;
  }
  Fld[I_Sel][J_Sel]=-2; //All the following stuff is only for getting MoveCLine for the graphics
  FindJumpFields(kk, 2);
  for (iik=I_Sel-1; iik<=I_Sel+1; iik++)
  { for (jjk=J_Sel-1; jjk<=J_Sel+1; jjk++)
    { if (IsInField(iik, jjk))
      { if (Fld[iik][jjk]<0) Fld[iik][jjk]=-3;
      }
    }
  }
  mm=Fld[iib][jjb];
  iismm=false;
  NCLine=1;
  MoveCLine[NCLine-1][0]=iib;
  MoveCLine[NCLine-1][1]=jjb;
  while (mm<-3)
  { iik=MoveCLine[NCLine-1][0];
    jjk=MoveCLine[NCLine-1][1];
    for (iid=-1; iid<=1; iid++)
    { for(jjd=-1; jjd<=1; jjd++)
      { if ((iid!=0)||(jjd!=0))
        { iis=iik;
          jjs=jjk;
          while (IsInField(iis+iid, jjs+jjd)&&(Fld[iis][jjs]<0))
          { iis+=iid; jjs+=jjd;
          }
          if (IsInField(2*iis-iik, 2*jjs-jjk))
          { iis*=2;
            iis-=iik;
            jjs*=2;
            jjs-=jjk;
            dd=0;
            nn=0;
            while ((iis-dd*iid!=iik)||(jjs-dd*jjd!=jjk))
            { if (Fld[iis-dd*iid][jjs-dd*jjd]>=0) nn++;
              dd++;
            }
            if ((nn==1)&&(!iismm))
            { if (Fld[iis][jjs]==mm+1)
              { iismm=true;
                NCLine++;
                MoveCLine[NCLine-1][0]=iis;
                MoveCLine[NCLine-1][1]=jjs;
              }
            }
          }
        }
      }
    }
    mm++;
    iismm=false;
  }
  NCLine++;
  MoveCLine[NCLine-1][0]=I_Sel;
  MoveCLine[NCLine-1][1]=J_Sel;
  Fld[I_Sel][J_Sel]=kk;
  CleanUpFields();
  NDraw=NCLine+1;
  MakeMove(iib, jjb);
  MoveText();
}

function MakeMove(ii, jj)
{ if (IsOver) return;
  Fld[ii][jj]=(MoveCount+Start)%2;
  Fld[I_Sel][J_Sel]=-1;
  if (FldH[MoveCount][0]!=I_Sel)
  { FldH[MoveCount][0]=I_Sel;
    MaxMoveCount=MoveCount+1;
  }
  if (FldH[MoveCount][1]!=J_Sel)
  { FldH[MoveCount][1]=J_Sel;
    MaxMoveCount=MoveCount+1;
  }
  if (FldH[MoveCount][2]!=ii)
  { FldH[MoveCount][2]=ii;
    MaxMoveCount=MoveCount+1;
  }
  if (FldH[MoveCount][3]!=jj)
  { FldH[MoveCount][3]=jj;
    MaxMoveCount=MoveCount+1;
  }
  MoveCount++;
  if (MaxMoveCount<MoveCount)
    MaxMoveCount=MoveCount;
  I_Sel=-1;
  J_Sel=-1;
  NLine=0;
}

function MoveText()
{ var ii, jj, kk, kk0=0, kk1=0;
  RefreshScreen();
  for (ii=0; ii<MaxFld; ii++)
  { for (jj=0; jj<MaxFld; jj++)
    { if ((kk=Fld[ii][jj])==Home(ii, jj))
      { if (kk==0) kk0++;
        if (kk==1) kk1++;
      }
    }
  }
  if (Fld[MaxFld-2][0]==1) kk0++;
  if (Fld[MaxFld-1][0]==1) kk0++;
  if (Fld[MaxFld-1][1]==1) kk0++;
  if (Fld[0][MaxFld-2]==0) kk1++;
  if (Fld[0][MaxFld-1]==0) kk1++;
  if (Fld[1][MaxFld-1]==0) kk1++;
  if ((kk0==19)||(kk1==19)) IsOver=true;
  if (! IsOver)
  { if (MoveCount==MaxMove-1)
    { IsOver=true;
      alert("Unetschieden !");
    }
  }
  else
  { if ((MoveCount+Start)%2==1)
      alert("Gelb gewinnt !");
    else
      alert("Grün gewinnt !");
  }
}

function RefreshScreen()
{ var kk;
  if (NDraw>0) NDraw--;
  if (NDraw==0)
  { for (i=0; i<MaxFld; i++)
    { for (j=0; j<MaxFld; j++)
      { if (window.document.images[MaxFld*j+i].src != Pic[(i+j)%2][Fld[i][j]+1].src)
          window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][Fld[i][j]+1].src;
      }
    }
  }
  for (kk=0; kk<NLine-1; kk++)
  { i=MoveLine[kk][0];
    j=MoveLine[kk][1];
    if (window.document.images[MaxFld*j+i].src != Pic[(i+j)%2][5].src)
      window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][5].src;
  }
  if (NLine>0)
  { i=MoveLine[NLine-1][0];
    j=MoveLine[NLine-1][1];
    if (window.document.images[MaxFld*j+i].src != Pic[(i+j)%2][Fld[I_Sel][J_Sel]+3].src)
      window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][Fld[I_Sel][J_Sel]+3].src;
  }
  if (NDraw>0)
  { for (kk=NDraw-1; kk<NCLine; kk++)
    { i=MoveCLine[kk][0];
      j=MoveCLine[kk][1];
      if (window.document.images[MaxFld*j+i].src != Pic[(i+j)%2][5].src)
        window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][5].src;
    }
    i=MoveCLine[NDraw-1][0];
    j=MoveCLine[NDraw-1][1];
    kk=(MoveCount+Start+1)%2;
    if (NDraw>0)
      window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][kk+3].src;
    else
      window.document.images[MaxFld*j+i].src = Pic[(i+j)%2][kk+1].src;
  }
  if (MoveCount>99)
    window.document.OptionsForm.Moves.value=MoveCount;
  else
  { if (MoveCount>9)
      window.document.OptionsForm.Moves.value=" "+MoveCount+" ";
    else
      window.document.OptionsForm.Moves.value="  "+MoveCount+"  ";
  }
}

function Resize()
{ if(navigator.appName == "Netscape") history.go(0);
}

function Help()
{ alert("Halma ist ein bekanntes Spiel, es wird aber meist auf einem sternförmigen"+
      "\nBrett gespielt. Diese Version von Halma wird auf einem quadratischen Brett"+
      "\ngespielt und es gibt im Gegensatz zum normalen Halma eine weitere Regel:"+
      "\nEs können hier auch lange Sprünge gemacht werden, das heißt, es kann über"+
      "\neinen Stein gesprungen werden, wenn die Anzahl der leeren Felder vor dem"+
      "\ngesprungenen Stein gleich ist zur Anzahl der leeren Felder nach dem Stein."+
      "\nWenn du einen Stein setzen willst, dann klicke auf ihn. Klicke danach auf"+
      "\nalle Felder, die zu dem Zug gehören, in der richtigen Reihenfolge. Klicke"+
      "\nam Ende des Zuges noch einmal auf den Stein.");
}
</script>
</head>
<BODY bgcolor=#CCAA77 text=#000000 onResize="javascript:Resize()">
<form name="OptionsForm">
<DIV ALIGN=center>
<table noborder>
<tr>
  <td><table border=5 bgcolor=#A0A0A0 cellpadding=2 cellspacing=0>
      <script language="JavaScript">
      document.open("text/plain");
      for (i=0; i < MaxFld; i++)
      { document.writeln("<tr align=center>");
        for (j=0; j < MaxFld; j++)
        { if ((i+j)%2==0)
          { if (Home(i,j)>=0)
              document.writeln("<td bgcolor=#000000><IMG src=\"halma00.gif\" border=0 onMouseDown=\"Clicked("+j+","+i+")\"></td>");
            else
              document.writeln("<td bgcolor=#E0E0E0><IMG src=\"halma00.gif\" border=0 onMouseDown=\"Clicked("+j+","+i+")\"></td>");
          }
          else
          { if (Home(i,j)>=0)
              document.writeln("<td bgcolor=#000000><IMG src=\"halma10.gif\" border=0 onMouseDown=\"Clicked("+j+","+i+")\"></td>");
            else
              document.writeln("<td bgcolor=#A0A0A0><IMG src=\"halma10.gif\" border=0 onMouseDown=\"Clicked("+j+","+i+")\"></td>");
          }
        }
        document.writeln("</tr>");
      }
      document.close();
      </script>
      </table>
  </td>
  <td>&nbsp;</td>
  <td>
      <table noborder cellpadding=0 cellspacing=0>
      <tr><td>
        <table border=3 cellpadding=2 cellspacing=1 width=100% bgcolor=#DDBB88>
        <tr><td><input type=radio name="Yellow" checked value="Yellow: Player" onClick="javascript:SetOption(0,0)"><b>Gelb: Spieler</b></td></tr>
        <tr><td><input type=radio name="Yellow" value="Yellow: Computer (Advanced Mode)" onClick="javascript:SetOption(0,1)"><b>Computer <I>Fortgeschrittener</I></b></td></tr>
        <tr><td><input type=radio name="Yellow" value="Yellow: Computer (Expert Mode)" onClick="javascript:SetOption(0,2)"><b>Computer <I>Experte</I></b></td></tr>
        </table>      
      </td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td>
        <table border=3 cellpadding=2 cellspacing=1 width=100% bgcolor=#DDBB88>
        <tr><td><input type=radio name="Green" value="Green: Player" onClick="javascript:SetOption(1,0)"><b>Gr&uuml;n: Spieler</b></td></tr>
        <tr><td><input type=radio name="Green" value="Green: Computer (Advanced Mode)" onClick="javascript:SetOption(1,1)"><b>Computer <I>Fortgeschrittener</b></I></td></tr>
        <tr><td><input type=radio name="Green" checked value="Green: Computer (Expert Mode)" onClick="javascript:SetOption(1,2)"><b>Computer <I>Experte</I></b></td></tr>
        </table>
      </td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td>
        <table border=3 cellpadding=2 cellspacing=1 width=100% bgcolor=#DDBB88>
        <tr><td width=60%><input type=radio name="Start" checked value="Yellow" onClick="javascript:SetOption(2,1)"><b>Gelb beginnt</b></td></tr>
        <tr><td width=60%><input type=radio name="Start" value="Green" onClick="javascript:SetOption(2,0)"><b>Gr&uuml;n beginnt</b></td></tr>
        </table>
      </td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td>
        <table border=3 cellpadding=2 cellspacing=1 width=100% bgcolor=#DDBB88><tr>
        <td width=20% align=center><input type=button value="&lt;&lt;" width=35 style="width:35" onClick="javascript:Back();Back()" title="zwei Z&uuml;ge zur&uuml;ck"></td>
        <td width=20% align=center><input type=button value="&lt;" width=35 style="width:35" onClick="javascript:Back()" title="einen Zug zur&uuml;ck"></td>
        <td width=20% align=center><input type=button value="&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" width=35 style="width:33;background-color:#FFFFFF;font-weight:bold" disabled name="Moves"></td>
        <td width=20% align=center><input type=button value="&gt;" width=35 style="width:35" onClick="javascript:Replay()" title="einen Zug vorw&auml;rts"></td>
        <td width=20% align=center><input type=button value="&gt;&gt;" width=35 style="width:35" onClick="javascript:Replay();Replay()" title="zwei Z&uuml;ge vorw&auml;rts"></td>
        </tr></table>
      </td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td>
        <table border=3 cellpadding=2 cellspacing=1 width=100% bgcolor=#DDBB88><tr>
        <td align=center><input type=button value="Neues Spiel" width=100 style="width:100" onClick="javascript:Init()"></td>
        <td align=center><input type=button value="Hilfe" width=100 style="width:100" onClick="javascript:Help()"></td></tr>
        </table>
      </td></tr>
      </table>
  </td>
</tr>
</table>
</DIV>
</form>
<script language="JavaScript">
Init();
setInterval("Timer()",500);
</script>
</BODY>
</HTML>
